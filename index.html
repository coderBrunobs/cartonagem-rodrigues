<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Visualizador 3D de Caixa (Papelão Realista)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --panel-w: 360px; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    body { margin: 0; height: 100vh; overflow: hidden; background:#eef0f2; }
    #canvas-wrap { position:absolute; left:0; top:0; right:var(--panel-w); bottom:0; }
    #ui {
      position: absolute;
      right: 12px;
      top: 12px;
      width: var(--panel-w);
      height: calc(100% - 24px);
      background: rgba(255,255,255,0.98);
      box-shadow: 0 8px 30px rgba(0,0,0,0.12);
      border-radius: 10px;
      padding: 14px;
      z-index: 10;
      overflow:auto;
    }
    h3 { margin:0 0 8px 0; font-size:16px; }
    label { display:block; font-size:13px; color:#222; margin-top:10px; }
    input[type="number"], select, input[type="text"] { width:100%; padding:8px; border-radius:6px; border:1px solid #ddd; margin-top:6px; box-sizing:border-box; font-size:14px; background:white; }
    input[type="color"] { width: 44px; height: 34px; padding:0; border:none; margin-top:6px; vertical-align:middle; }
    .row { display:flex; gap:8px; align-items:center; }
    button { margin-top:10px; width:100%; padding:9px; border-radius:8px; border:none; background:#2b7a4a; color:white; font-weight:600; cursor:pointer; font-size:14px; }
    button.secondary { background:#6b7280; }
    small { color:#666; display:block; margin-top:6px; font-size:12px; }
    .compact { padding:6px; font-size:13px; }
    .inline { display:inline-block; vertical-align:middle; }
    .controls-grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    footer { position:absolute; left:12px; bottom:12px; background:rgba(255,255,255,0.95); padding:8px;border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.06); font-size:13px; z-index:9; }
    .small-muted { font-size:12px; color:#666; }
  </style>
</head>
<body>
  <div id="canvas-wrap"></div>

  <div id="ui">
    <h3>Visualizador de Caixa — Papelão</h3>

    <label>Largura (mm)</label>
    <input id="input-width" type="number" min="10" value="150">

    <label>Comprimento / Profundidade (mm)</label>
    <input id="input-depth" type="number" min="10" value="120">

    <label>Altura (mm)</label>
    <input id="input-height" type="number" min="5" value="80">

    <div class="row">
      <button id="apply-dim" class="compact">Aplicar Dimensões</button>
      <button id="fit" class="compact secondary">Enquadrar</button>
    </div>

    <label>Cor base do papelão</label>
    <div style="display:flex; align-items:center; gap:8px;">
      <input id="color-picker" type="color" value="#d39b45">
      <small class="small-muted">Cor base (influencia a textura)</small>
    </div>

    <label>Upload de Imagem / Logo</label>
    <input id="upload" type="file" accept="image/*">
    <label>Aplicar em</label>
    <select id="face-select">
      <option value="all">Todas as faces</option>
      <option value="front">Frente (+Z)</option>
      <option value="back">Traseira (-Z)</option>
      <option value="left">Lateral esquerda (-X)</option>
      <option value="right">Lateral direita (+X)</option>
      <option value="top">Topo (+Y)</option>
      <option value="bottom">Base (-Y)</option>
    </select>

    <label>Posição / Escala da Imagem (apenas face selecionada)</label>
    <div class="controls-grid">
      <input id="img-scale" type="number" value="0.6" step="0.05" min="0.05" title="escala">
      <input id="img-offset-x" type="number" value="0" step="1" title="offsetX">
      <input id="img-offset-y" type="number" value="0" step="1" title="offsetY">
      <button id="apply-texture" class="compact">Aplicar Imagem</button>
    </div>
    <div class="row">
      <button id="remove-texture" class="secondary compact">Remover Imagem</button>
      <button id="toggle-wire" class="secondary compact">Wireframe</button>
    </div>

    <label>Opções</label>
    <div class="row">
      <button id="export" class="compact">Exportar Screenshot</button>
      <button id="download-dieline" class="compact secondary">Baixar Dieline (simples)</button>
    </div>

    <small style="margin-top:8px;" class="small-muted">
      Dica: Use PNG com fundo transparente para logos. Se quiser dieline/uv real para impressão, eu gero um .glb UV-unwrapped posteriormente.
    </small>
  </div>

  <footer>Prototipo • Arraste para girar • Scroll para zoom</footer>

  <!-- three.js e OrbitControls - versões atualizadas -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

  <script>
  // ---------- Setup básico ----------
  const container = document.getElementById('canvas-wrap');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f2f4);

  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 5000);
  camera.position.set(400, 260, 420);

  const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
  renderer.shadowMap.enabled = true; // Ativar sombras
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves
  container.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 40, 0);
  controls.update();

  // Luzes - configuradas para sombras
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);
  hemi.position.set(0, 200, 0);
  scene.add(hemi);
  
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(300, 400, 200);
  dir.castShadow = true;
  dir.shadow.camera.near = 0.1;
  dir.shadow.camera.far = 2000;
  dir.shadow.camera.left = -500;
  dir.shadow.camera.right = 500;
  dir.shadow.camera.top = 500;
  dir.shadow.camera.bottom = -500;
  dir.shadow.mapSize.width = 1024;
  dir.shadow.mapSize.height = 1024;
  scene.add(dir);

  // Adicionar luz ambiente para melhor iluminação
  const ambient = new THREE.AmbientLight(0x404040);
  scene.add(ambient);

  // Chao suave
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(2000, 2000), 
    new THREE.MeshStandardMaterial({ color: 0xf6f6f6 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.1;
  ground.receiveShadow = true;
  scene.add(ground);

  // Estado
  let boxMesh = null;
  let faceMaterials = [];
  let currentFaceTextureCanvas = {}; // store canvas per face for redraws
  let currentTextureImage = null;
  let wireframe = false;

  // Face map for BoxGeometry material order: +X, -X, +Y, -Y, +Z, -Z
  const faceMap = { right:0, left:1, top:2, bottom:3, front:4, back:5 };

  // ---------- Funções utilitárias de textura (canvas) ----------
  function makeCardboardCanvas(w=1024, h=1024, baseColor='#d39b45', drawDieline=true) {
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d');

    // base
    ctx.fillStyle = baseColor;
    ctx.fillRect(0,0,w,h);

    // subtle noise: draw many semi-transparent strokes
    for (let i=0;i<1200;i++){
      ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.02})`;
      const x = Math.random()*w, y = Math.random()*h, rw = Math.random()*3;
      ctx.fillRect(x,y,rw,1);
    }

    // faint streaks
    ctx.globalAlpha = 0.08;
    for (let i=0;i<6;i++){
      ctx.beginPath();
      ctx.moveTo(0, Math.random()*h);
      ctx.quadraticCurveTo(w*0.5, Math.random()*h, w, Math.random()*h);
      ctx.lineWidth = 40 + Math.random()*120;
      ctx.strokeStyle = '#000';
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // subtle vignette
    const grad = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)/4, w/2, h/2, Math.max(w,h)/1.2);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.08)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    // desenhar "dieline" - bordas e linhas de dobra
    if (drawDieline) {
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8,6]);
      // frame
      ctx.strokeRect(8,8,w-16,h-16);
      // cross lines (simples sugestão)
      ctx.beginPath();
      ctx.moveTo(w/2, 8);
      ctx.lineTo(w/2, h-8);
      ctx.moveTo(8, h/2);
      ctx.lineTo(w-8, h/2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // subtle paper fibers texture (tiny dots)
    const imgd = ctx.getImageData(0,0,w,h);
    const data = imgd.data;
    for (let i=0;i<5000;i++){
      const px = Math.floor(Math.random()*w);
      const py = Math.floor(Math.random()*h);
      const idx = (py*w + px) * 4;
      data[idx] = Math.min(255, data[idx] + (Math.random()*40));
      data[idx+1] = Math.min(255, data[idx+1] + (Math.random()*10));
      data[idx+2] = Math.min(255, data[idx+2] + (Math.random()*4));
    }
    ctx.putImageData(imgd, 0,0);

    return c;
  }

  // quick normal map from grayscale canvas (very simple)
  function makeNormalMapFromCanvas(srcCanvas) {
    const w = srcCanvas.width, h = srcCanvas.height;
    const sctx = srcCanvas.getContext('2d');
    const src = sctx.getImageData(0,0,w,h);
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d');
    const dest = ctx.createImageData(w,h);

    function lum(i){ return (src.data[i]*0.3 + src.data[i+1]*0.59 + src.data[i+2]*0.11)/255; }
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i = (y*w + x)*4;
        const l = lum(i);
        const rx = lum(((y)*w + Math.max(0,x-1))*4) - lum(((y)*w + Math.min(w-1,x+1))*4);
        const ry = lum((Math.max(0,y-1)*w + x)*4) - lum((Math.min(h-1,y+1)*w + x)*4);
        const dx = (rx + 1) * 0.5 * 255;
        const dy = (ry + 1) * 0.5 * 255;
        dest.data[i] = Math.floor(dx);
        dest.data[i+1] = Math.floor(dy);
        dest.data[i+2] = 255;
        dest.data[i+3] = 255;
      }
    }
    ctx.putImageData(dest, 0,0);
    return c;
  }

  // ---------- Criar materiais / caixa ----------
  function createCardboardMaterials(baseColor) {
    // cria materiais 6 faces, cada um com sua CanvasTexture
    const mats = [];
    faceMaterials = [];
    currentFaceTextureCanvas = {};

    for (let i=0;i<6;i++){
      const canvas = makeCardboardCanvas(1024,1024, baseColor, true);
      currentFaceTextureCanvas[i] = canvas;

      const texture = new THREE.CanvasTexture(canvas);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      texture.encoding = THREE.sRGBEncoding;

      const normalCanvas = makeNormalMapFromCanvas(canvas);
      const normalTex = new THREE.CanvasTexture(normalCanvas);

      const mat = new THREE.MeshStandardMaterial({
        map: texture,
        normalMap: normalTex,
        metalness: 0.02,
        roughness: 0.9,
        color: 0xFFFFFF
      });
      mats.push(mat);
      faceMaterials.push(mat);
    }
    return mats;
  }

  function createBox(widthMM, depthMM, heightMM, baseColor) {
    // remove antigo
    if (boxMesh) {
      scene.remove(boxMesh);
      boxMesh.geometry.dispose();
      faceMaterials.forEach(m => {
        if (m.map) m.map.dispose();
        if (m.normalMap) m.normalMap.dispose();
        m.dispose();
      });
      faceMaterials = [];
      boxMesh = null;
    }

    const w = Math.max(1, widthMM);
    const h = Math.max(1, heightMM);
    const d = Math.max(1, depthMM);

    const geometry = new THREE.BoxGeometry(w, h, d);
    // ajustar origem para a base em y=0
    geometry.translate(0, h/2, 0);

    const mats = createCardboardMaterials(document.getElementById('color-picker').value);
    boxMesh = new THREE.Mesh(geometry, mats);
    boxMesh.castShadow = true;
    boxMesh.receiveShadow = true;
    scene.add(boxMesh);

    // centraliza camera
    focusBox();
  }

  function focusBox() {
    if (!boxMesh) return;
    const bbox = new THREE.Box3().setFromObject(boxMesh);
    const size = bbox.getSize(new THREE.Vector3());
    const center = bbox.getCenter(new THREE.Vector3());
    const maxSize = Math.max(size.x, size.y, size.z);
    const fitDistance = maxSize * 2.0 + 120;
    camera.position.set(center.x + fitDistance, center.y + fitDistance*0.5, center.z + fitDistance);
    controls.target.copy(center);
    controls.update();
  }

  // Inicial - criar a primeira caixa
  setTimeout(() => {
    createBox(
      parseFloat(document.getElementById('input-width').value),
      parseFloat(document.getElementById('input-depth').value),
      parseFloat(document.getElementById('input-height').value),
      document.getElementById('color-picker').value
    );
  }, 100);

  // ---------- Aplicar imagem (logo) numa face específica ----------
  let uploadedImage = null;
  document.getElementById('upload').addEventListener('change', (ev) => {
    const f = ev.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => { uploadedImage = img; alert('Imagem carregada. Selecione face e clique em "Aplicar Imagem".'); };
      img.src = e.target.result;
    };
    reader.readAsDataURL(f);
  });

  // função para redesenhar a canvas de uma face incluindo o logo com posicionamento
  function drawImageOnFaceCanvas(faceIdx, img, scale=0.6, offsetX=0, offsetY=0) {
    const canvas = currentFaceTextureCanvas[faceIdx];
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    // Recriar base (mantém a textura já feita). Vamos redraw mantendo tudo e então desenhar o logo.
    // Para simplicidade, recalc base com makeCardboardCanvas but keep original feel.
    const base = makeCardboardCanvas(canvas.width, canvas.height, document.getElementById('color-picker').value, true);
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.drawImage(base, 0,0);

    // Draw logo centered with scale and offsets (offsets in px)
    const maxW = canvas.width * scale;
    const maxH = canvas.height * scale;
    const imgRatio = img.width / img.height;
    let drawW = maxW, drawH = maxH;
    if (img.width > img.height) {
      drawH = maxW / imgRatio;
      if (drawH > maxH) { drawH = maxH; drawW = drawH * imgRatio; }
    } else {
      drawW = maxH * imgRatio;
      if (drawW > maxW) { drawW = maxW; drawH = drawW / imgRatio; }
    }
    const cx = canvas.width/2 + parseFloat(offsetX || 0);
    const cy = canvas.height/2 + parseFloat(offsetY || 0);
    ctx.drawImage(img, cx - drawW/2, cy - drawH/2, drawW, drawH);

    // small border around logo to help visibility
    ctx.strokeStyle = 'rgba(0,0,0,0.18)';
    ctx.lineWidth = 2;
    ctx.strokeRect(cx - drawW/2 - 4, cy - drawH/2 - 4, drawW + 8, drawH + 8);

    // update texture and normal map
    const mat = faceMaterials[faceIdx];
    if (mat) {
      if (mat.map) mat.map.dispose();
      if (mat.normalMap) mat.normalMap.dispose();
      const tex = new THREE.CanvasTexture(canvas);
      tex.encoding = THREE.sRGBEncoding; tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      mat.map = tex;

      const normalCanvas = makeNormalMapFromCanvas(canvas);
      const normalTex = new THREE.CanvasTexture(normalCanvas);
      mat.normalMap = normalTex;

      mat.needsUpdate = true;
    }
  }

  // Aplica imagem ao selecionar face / all
  document.getElementById('apply-texture').addEventListener('click', () => {
    if (!uploadedImage) { alert('Faça upload de uma imagem primeiro.'); return; }
    const faceKey = document.getElementById('face-select').value;
    const scale = parseFloat(document.getElementById('img-scale').value) || 0.6;
    const offX = parseFloat(document.getElementById('img-offset-x').value) || 0;
    const offY = parseFloat(document.getElementById('img-offset-y').value) || 0;

    if (faceKey === 'all') {
      for (let i=0;i<6;i++) drawImageOnFaceCanvas(i, uploadedImage, scale, offX, offY);
    } else {
      const idx = faceMap[faceKey];
      drawImageOnFaceCanvas(idx, uploadedImage, scale, offX, offY);
    }
  });

  document.getElementById('remove-texture').addEventListener('click', () => {
    // rebuild faces without logo
    for (let i=0;i<6;i++) {
      const canvas = makeCardboardCanvas(1024,1024, document.getElementById('color-picker').value, true);
      currentFaceTextureCanvas[i] = canvas;
      const tex = new THREE.CanvasTexture(canvas);
      tex.encoding = THREE.sRGBEncoding; tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      faceMaterials[i].map = tex;
      faceMaterials[i].normalMap = new THREE.CanvasTexture(makeNormalMapFromCanvas(canvas));
      faceMaterials[i].needsUpdate = true;
    }
    uploadedImage = null;
    document.getElementById('upload').value = '';
  });

  // ---------- Eventos UI ----------
  document.getElementById('apply-dim').addEventListener('click', () => {
    const w = parseFloat(document.getElementById('input-width').value) || 150;
    const d = parseFloat(document.getElementById('input-depth').value) || 120;
    const h = parseFloat(document.getElementById('input-height').value) || 80;
    createBox(w, d, h, document.getElementById('color-picker').value);
  });

  document.getElementById('color-picker').addEventListener('input', (e) => {
    // recoloriza mantendo o desenho: recria materiais com nova cor base
    if (!boxMesh) return;
    for (let i=0;i<6;i++){
      const canvas = makeCardboardCanvas(1024,1024, e.target.value, true);
      currentFaceTextureCanvas[i] = canvas;
      if (faceMaterials[i]) {
        if (faceMaterials[i].map) faceMaterials[i].map.dispose();
        if (faceMaterials[i].normalMap) faceMaterials[i].normalMap.dispose();
        faceMaterials[i].map = new THREE.CanvasTexture(canvas);
        faceMaterials[i].normalMap = new THREE.CanvasTexture(makeNormalMapFromCanvas(canvas));
        faceMaterials[i].needsUpdate = true;
      }
    }
  });

  document.getElementById('toggle-wire').addEventListener('click', () => {
    wireframe = !wireframe;
    faceMaterials.forEach(m => m.wireframe = wireframe);
  });

  document.getElementById('fit').addEventListener('click', () => focusBox());

  document.getElementById('export').addEventListener('click', () => {
    renderer.render(scene, camera);
    const url = renderer.domElement.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url; a.download = 'caixa_preview.png'; a.click();
  });

  // Simple dieline download (2D rough) - creates an SVG with rectangle based on dims
  document.getElementById('download-dieline').addEventListener('click', () => {
    const w = parseFloat(document.getElementById('input-width').value) || 150;
    const d = parseFloat(document.getElementById('input-depth').value) || 120;
    const h = parseFloat(document.getElementById('input-height').value) || 80;
    // This is a very simplistic dieline representation for preview only
    const scale = 2; // px per mm for preview
    const svgW = (w*3 + d*2 + 120) * scale;
    const svgH = (h*2 + d + 120) * scale;
    const offsetX = 60*scale, offsetY = 60*scale;
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}">`;
    svg += `<rect x="${offsetX}" y="${offsetY}" width="${w*scale}" height="${h*scale}" fill="none" stroke="#000" stroke-dasharray="6,4"/>`; // front
    svg += `<rect x="${offsetX + w*scale}" y="${offsetY}" width="${d*scale}" height="${h*scale}" fill="none" stroke="#000" stroke-dasharray="6,4"/>`; // right
    svg += `<rect x="${offsetX - d*scale}" y="${offsetY}" width="${d*scale}" height="${h*scale}" fill="none" stroke="#000" stroke-dasharray="6,4"/>`; // left
    svg += `<rect x="${offsetX}" y="${offsetY - h*scale}" width="${w*scale}" height="${d*scale}" fill="none" stroke="#000" stroke-dasharray="6,4"/>`; // top
    svg += `<text x="10" y="${svgH-10}" font-size="14">Dieline preview (não para impressão) - w=${w}mm d=${d}mm h=${h}mm</text>`;
    svg += `</svg>`;
    const blob = new Blob([svg], {type: 'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'dieline_preview.svg'; a.click();
    URL.revokeObjectURL(url);
  });

  // ---------- Responsividade e loop ----------
  window.addEventListener('resize', () => {
    renderer.setSize(container.clientWidth, container.clientHeight);
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
  });

  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  // ---------- Mensagem de prontidão ----------
  console.log('Visualizador pronto — caixa criada. Use os controles à direita.');
  </script>
</body>
</html>